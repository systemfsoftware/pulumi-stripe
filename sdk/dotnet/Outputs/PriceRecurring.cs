// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Stripe.Outputs
{

    [OutputType]
    public sealed class PriceRecurring
    {
        /// <summary>
        /// Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        /// </summary>
        public readonly string? AggregateUsage;
        /// <summary>
        /// Specifies billing frequency. Either day, week, month or year.
        /// </summary>
        public readonly string Interval;
        /// <summary>
        /// The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        /// </summary>
        public readonly int? IntervalCount;
        /// <summary>
        /// The meter tracking the usage of a metered price
        /// </summary>
        public readonly string? Meter;
        /// <summary>
        /// Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        /// </summary>
        public readonly string? UsageType;

        [OutputConstructor]
        private PriceRecurring(
            string? aggregateUsage,

            string interval,

            int? intervalCount,

            string? meter,

            string? usageType)
        {
            AggregateUsage = aggregateUsage;
            Interval = interval;
            IntervalCount = intervalCount;
            Meter = meter;
            UsageType = usageType;
        }
    }
}
