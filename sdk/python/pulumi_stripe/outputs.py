# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'FileLink',
    'FileLinkData',
    'PortalConfigurationBusinessProfile',
    'PortalConfigurationFeatures',
    'PortalConfigurationFeaturesCustomerUpdate',
    'PortalConfigurationFeaturesInvoiceHistory',
    'PortalConfigurationFeaturesPaymentMethodUpdate',
    'PortalConfigurationFeaturesSubscriptionCancel',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReason',
    'PortalConfigurationFeaturesSubscriptionPause',
    'PortalConfigurationFeaturesSubscriptionUpdate',
    'PortalConfigurationFeaturesSubscriptionUpdateProduct',
    'PortalConfigurationLoginPage',
    'PriceCurrencyOption',
    'PriceCurrencyOptionCustomUnitAmount',
    'PriceCurrencyOptionTier',
    'PriceRecurring',
    'PriceTier',
    'PriceTransformQuantity',
    'PromotionCodeRestrictions',
    'ShippingRateDeliveryEstimate',
    'ShippingRateDeliveryEstimateMaximum',
    'ShippingRateDeliveryEstimateMinimum',
    'ShippingRateFixedAmount',
    'ShippingRateFixedAmountCurrencyOption',
]

@pulumi.output_type
class FileLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created: Optional[builtins.int] = None,
                 expired: Optional[builtins.bool] = None,
                 expires_at: Optional[builtins.int] = None,
                 id: Optional[builtins.str] = None,
                 livemode: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 object: Optional[builtins.str] = None,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.int created: Time at which the object was created. Measured in seconds since the Unix epoch.
        :param builtins.bool expired: Returns if the link is already expired.
        :param builtins.int expires_at: Time that the link expires
        :param builtins.str id: Unique identifier for the object.
        :param builtins.bool livemode: Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        :param Mapping[str, builtins.str] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        :param builtins.str object: String representing the object’s type. Objects of the same type share the same value.
        :param builtins.str url: The publicly accessible URL to download the file.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if livemode is not None:
            pulumi.set(__self__, "livemode", livemode)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def created(self) -> Optional[builtins.int]:
        """
        Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def expired(self) -> Optional[builtins.bool]:
        """
        Returns if the link is already expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[builtins.int]:
        """
        Time that the link expires
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique identifier for the object.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def livemode(self) -> Optional[builtins.bool]:
        """
        Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        """
        return pulumi.get(self, "livemode")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def object(self) -> Optional[builtins.str]:
        """
        String representing the object’s type. Objects of the same type share the same value.
        """
        return pulumi.get(self, "object")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The publicly accessible URL to download the file.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FileLinkData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileLinkData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileLinkData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileLinkData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create: builtins.bool,
                 expires_at: Optional[builtins.int] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.bool create: Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        :param builtins.int expires_at: The link isn’t available after this future timestamp.
        :param Mapping[str, builtins.str] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        pulumi.set(__self__, "create", create)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def create(self) -> builtins.bool:
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[builtins.int]:
        """
        The link isn’t available after this future timestamp.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class PortalConfigurationBusinessProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privacyPolicyUrl":
            suggest = "privacy_policy_url"
        elif key == "termsOfServiceUrl":
            suggest = "terms_of_service_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationBusinessProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationBusinessProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headline: Optional[builtins.str] = None,
                 privacy_policy_url: Optional[builtins.str] = None,
                 terms_of_service_url: Optional[builtins.str] = None):
        """
        :param builtins.str headline: The messaging shown to customers in the portal.
        :param builtins.str privacy_policy_url: A link to the business's publicly available privacy policy.
        :param builtins.str terms_of_service_url: A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @property
    @pulumi.getter
    def headline(self) -> Optional[builtins.str]:
        """
        The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[builtins.str]:
        """
        A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[builtins.str]:
        """
        A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")


@pulumi.output_type
class PortalConfigurationFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerUpdate":
            suggest = "customer_update"
        elif key == "invoiceHistory":
            suggest = "invoice_history"
        elif key == "paymentMethodUpdate":
            suggest = "payment_method_update"
        elif key == "subscriptionCancel":
            suggest = "subscription_cancel"
        elif key == "subscriptionPauses":
            suggest = "subscription_pauses"
        elif key == "subscriptionUpdates":
            suggest = "subscription_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_update: Optional['outputs.PortalConfigurationFeaturesCustomerUpdate'] = None,
                 invoice_history: Optional['outputs.PortalConfigurationFeaturesInvoiceHistory'] = None,
                 payment_method_update: Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate'] = None,
                 subscription_cancel: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel'] = None,
                 subscription_pauses: Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionPause']] = None,
                 subscription_updates: Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']] = None):
        """
        :param 'PortalConfigurationFeaturesCustomerUpdateArgs' customer_update: Information about updating the customer details in the portal.
        :param 'PortalConfigurationFeaturesInvoiceHistoryArgs' invoice_history: Information about showing the billing history in the portal.
        :param 'PortalConfigurationFeaturesPaymentMethodUpdateArgs' payment_method_update: Information about updating payment methods in the portal.
        :param 'PortalConfigurationFeaturesSubscriptionCancelArgs' subscription_cancel: Information about canceling subscriptions in the portal.
        :param Sequence['PortalConfigurationFeaturesSubscriptionPauseArgs'] subscription_pauses: Information about pausing subscriptions in the portal.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateArgs'] subscription_updates: Information about updating subscriptions in the portal.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_pauses is not None:
            pulumi.set(__self__, "subscription_pauses", subscription_pauses)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional['outputs.PortalConfigurationFeaturesCustomerUpdate']:
        """
        Information about updating the customer details in the portal.
        """
        return pulumi.get(self, "customer_update")

    @property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional['outputs.PortalConfigurationFeaturesInvoiceHistory']:
        """
        Information about showing the billing history in the portal.
        """
        return pulumi.get(self, "invoice_history")

    @property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional['outputs.PortalConfigurationFeaturesPaymentMethodUpdate']:
        """
        Information about updating payment methods in the portal.
        """
        return pulumi.get(self, "payment_method_update")

    @property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancel']:
        """
        Information about canceling subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_cancel")

    @property
    @pulumi.getter(name="subscriptionPauses")
    def subscription_pauses(self) -> Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionPause']]:
        """
        Information about pausing subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_pauses")

    @property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdate']]:
        """
        Information about updating subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_updates")


@pulumi.output_type
class PortalConfigurationFeaturesCustomerUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUpdates":
            suggest = "allowed_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesCustomerUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesCustomerUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 allowed_updates: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        :param Sequence[builtins.str] allowed_updates: The types of customer updates that are supported. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[Sequence[builtins.str]]:
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")


@pulumi.output_type
class PortalConfigurationFeaturesInvoiceHistory(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesPaymentMethodUpdate(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cancellationReason":
            suggest = "cancellation_reason"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionCancel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionCancel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 cancellation_reason: Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason'] = None,
                 mode: Optional[builtins.str] = None,
                 proration_behavior: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        :param 'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs' cancellation_reason: Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        :param builtins.str mode: Whether to cancel subscriptions immediately or at the end of the billing period.
        :param builtins.str proration_behavior: Whether to create prorations when canceling subscriptions.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional['outputs.PortalConfigurationFeaturesSubscriptionCancelCancellationReason']:
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        return pulumi.get(self, "cancellation_reason")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[builtins.str]:
        """
        Whether to create prorations when canceling subscriptions.
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReason(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 options: Sequence[builtins.str]):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        :param Sequence[builtins.str] options: Which cancellation reasons will be given as options to the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def options(self) -> Sequence[builtins.str]:
        """
        Which cancellation reasons will be given as options to the customer.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionPause(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Whether the feature is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAllowedUpdates":
            suggest = "default_allowed_updates"
        elif key == "prorationBehavior":
            suggest = "proration_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortalConfigurationFeaturesSubscriptionUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortalConfigurationFeaturesSubscriptionUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_allowed_updates: Sequence[builtins.str],
                 enabled: builtins.bool,
                 products: Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct'],
                 proration_behavior: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] default_allowed_updates: The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        :param builtins.bool enabled: Whether the feature is enabled.
        :param Sequence['PortalConfigurationFeaturesSubscriptionUpdateProductArgs'] products: The list of products that support subscription updates.
        :param builtins.str proration_behavior: Determines how to handle prorations resulting from subscription updates
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> Sequence[builtins.str]:
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        return pulumi.get(self, "default_allowed_updates")

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def products(self) -> Sequence['outputs.PortalConfigurationFeaturesSubscriptionUpdateProduct']:
        """
        The list of products that support subscription updates.
        """
        return pulumi.get(self, "products")

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[builtins.str]:
        """
        Determines how to handle prorations resulting from subscription updates
        """
        return pulumi.get(self, "proration_behavior")


@pulumi.output_type
class PortalConfigurationFeaturesSubscriptionUpdateProduct(dict):
    def __init__(__self__, *,
                 prices: Sequence[builtins.str],
                 product: builtins.str):
        """
        :param Sequence[builtins.str] prices: The list of price IDs for the product that a subscription can be updated to.
        :param builtins.str product: The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @property
    @pulumi.getter
    def prices(self) -> Sequence[builtins.str]:
        """
        The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @property
    @pulumi.getter
    def product(self) -> builtins.str:
        """
        The product id.
        """
        return pulumi.get(self, "product")


@pulumi.output_type
class PortalConfigurationLoginPage(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.bool enabled: Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param builtins.str url: A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PriceCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customUnitAmount":
            suggest = "custom_unit_amount"
        elif key == "taxBehavior":
            suggest = "tax_behavior"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency: builtins.str,
                 custom_unit_amount: Optional['outputs.PriceCurrencyOptionCustomUnitAmount'] = None,
                 tax_behavior: Optional[builtins.str] = None,
                 tiers: Optional[Sequence['outputs.PriceCurrencyOptionTier']] = None,
                 unit_amount: Optional[builtins.int] = None,
                 unit_amount_decimal: Optional[builtins.float] = None):
        """
        :param builtins.str currency: Each currency must be a three-letter ISO currency code and a supported currency
        :param 'PriceCurrencyOptionCustomUnitAmountArgs' custom_unit_amount: When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
        :param builtins.str tax_behavior: Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param Sequence['PriceCurrencyOptionTierArgs'] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
        :param builtins.int unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param builtins.float unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> builtins.str:
        """
        Each currency must be a three-letter ISO currency code and a supported currency
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional['outputs.PriceCurrencyOptionCustomUnitAmount']:
        """
        When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
        """
        return pulumi.get(self, "custom_unit_amount")

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[builtins.str]:
        """
        Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @property
    @pulumi.getter
    def tiers(self) -> Optional[Sequence['outputs.PriceCurrencyOptionTier']]:
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
        """
        return pulumi.get(self, "tiers")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[builtins.int]:
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[builtins.float]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")


@pulumi.output_type
class PriceCurrencyOptionCustomUnitAmount(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool,
                 maximum: Optional[builtins.int] = None,
                 minimum: Optional[builtins.int] = None,
                 preset: Optional[builtins.int] = None):
        """
        :param builtins.bool enabled: Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
        :param builtins.int maximum: The maximum unit amount the customer can specify for this item.
        :param builtins.int minimum: The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
        :param builtins.int preset: The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[builtins.int]:
        """
        The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[builtins.int]:
        """
        The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def preset(self) -> Optional[builtins.int]:
        """
        The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")


@pulumi.output_type
class PriceCurrencyOptionTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceCurrencyOptionTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceCurrencyOptionTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[builtins.int] = None,
                 flat_amount_decimal: Optional[builtins.float] = None,
                 unit_amount: Optional[builtins.int] = None,
                 unit_amount_decimal: Optional[builtins.float] = None,
                 up_to: Optional[builtins.int] = None):
        """
        :param builtins.int flat_amount: The flat billing amount for an entire tier, regardless of the number of units in the tier.
        :param builtins.float flat_amount_decimal: Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        :param builtins.int unit_amount: The per unit billing amount for each individual unit for which this tier applies.
        :param builtins.float unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        :param builtins.int up_to: Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[builtins.int]:
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        return pulumi.get(self, "flat_amount")

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[builtins.float]:
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[builtins.int]:
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[builtins.float]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[builtins.int]:
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceRecurring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateUsage":
            suggest = "aggregate_usage"
        elif key == "intervalCount":
            suggest = "interval_count"
        elif key == "usageType":
            suggest = "usage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceRecurring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceRecurring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceRecurring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: builtins.str,
                 aggregate_usage: Optional[builtins.str] = None,
                 interval_count: Optional[builtins.int] = None,
                 usage_type: Optional[builtins.str] = None):
        """
        :param builtins.str interval: Specifies billing frequency. Either day, week, month or year.
        :param builtins.str aggregate_usage: Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        :param builtins.int interval_count: The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        :param builtins.str usage_type: Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @property
    @pulumi.getter
    def interval(self) -> builtins.str:
        """
        Specifies billing frequency. Either day, week, month or year.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[builtins.str]:
        """
        Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[builtins.int]:
        """
        The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[builtins.str]:
        """
        Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        """
        return pulumi.get(self, "usage_type")


@pulumi.output_type
class PriceTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flatAmount":
            suggest = "flat_amount"
        elif key == "flatAmountDecimal":
            suggest = "flat_amount_decimal"
        elif key == "unitAmount":
            suggest = "unit_amount"
        elif key == "unitAmountDecimal":
            suggest = "unit_amount_decimal"
        elif key == "upTo":
            suggest = "up_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flat_amount: Optional[builtins.int] = None,
                 flat_amount_decimal: Optional[builtins.float] = None,
                 unit_amount: Optional[builtins.int] = None,
                 unit_amount_decimal: Optional[builtins.float] = None,
                 up_to: Optional[builtins.int] = None):
        """
        :param builtins.int flat_amount: The flat billing amount for an entire tier, regardless of the number of units in the tier.
        :param builtins.float flat_amount_decimal: Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        :param builtins.int unit_amount: The per unit billing amount for each individual unit for which this tier applies.
        :param builtins.float unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        :param builtins.int up_to: Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[builtins.int]:
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        return pulumi.get(self, "flat_amount")

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[builtins.float]:
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[builtins.int]:
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[builtins.float]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[builtins.int]:
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        return pulumi.get(self, "up_to")


@pulumi.output_type
class PriceTransformQuantity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "divideBy":
            suggest = "divide_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PriceTransformQuantity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PriceTransformQuantity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 divide_by: builtins.int,
                 round: builtins.str):
        """
        :param builtins.int divide_by: Divide usage by this number.
        :param builtins.str round: After division, either round the result up or down
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> builtins.int:
        """
        Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @property
    @pulumi.getter
    def round(self) -> builtins.str:
        """
        After division, either round the result up or down
        """
        return pulumi.get(self, "round")


@pulumi.output_type
class PromotionCodeRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstTimeTransaction":
            suggest = "first_time_transaction"
        elif key == "minimumAmount":
            suggest = "minimum_amount"
        elif key == "minimumAmountCurrency":
            suggest = "minimum_amount_currency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromotionCodeRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromotionCodeRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_time_transaction: builtins.bool,
                 minimum_amount: builtins.int,
                 minimum_amount_currency: builtins.str):
        """
        :param builtins.bool first_time_transaction: A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices
        :param builtins.int minimum_amount: Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param builtins.str minimum_amount_currency: Three-letter ISO code for minimum_amount
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        pulumi.set(__self__, "minimum_amount", minimum_amount)
        pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> builtins.bool:
        """
        A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices
        """
        return pulumi.get(self, "first_time_transaction")

    @property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> builtins.int:
        """
        Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> builtins.str:
        """
        Three-letter ISO code for minimum_amount
        """
        return pulumi.get(self, "minimum_amount_currency")


@pulumi.output_type
class ShippingRateDeliveryEstimate(dict):
    def __init__(__self__, *,
                 maximum: Optional['outputs.ShippingRateDeliveryEstimateMaximum'] = None,
                 minimum: Optional['outputs.ShippingRateDeliveryEstimateMinimum'] = None):
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMaximum']:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional['outputs.ShippingRateDeliveryEstimateMinimum']:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class ShippingRateDeliveryEstimateMaximum(dict):
    def __init__(__self__, *,
                 unit: builtins.str,
                 value: builtins.int):
        """
        :param builtins.str unit: The upper bound of the estimated range. If empty, represents no lower bound.
        :param builtins.int value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> builtins.str:
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateDeliveryEstimateMinimum(dict):
    def __init__(__self__, *,
                 unit: builtins.str,
                 value: builtins.int):
        """
        :param builtins.str unit: The lower bound of the estimated range. If empty, represents no lower bound.
        :param builtins.int value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> builtins.str:
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingRateFixedAmount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyOptions":
            suggest = "currency_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: builtins.int,
                 currency: builtins.str,
                 currency_options: Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']] = None):
        """
        :param builtins.int amount: A non-negative integer in cents representing how much to charge.
        :param builtins.str currency: Three-letter ISO currency code, in lowercase. Must be a supported currency.
        :param Sequence['ShippingRateFixedAmountCurrencyOptionArgs'] currency_options: Shipping rates defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. For example, to get your shipping rate in eur, fetch the value of the eur key in currency_options. This field is not included by default. To include it in the response, expand the currency_options field.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)

    @property
    @pulumi.getter
    def amount(self) -> builtins.int:
        """
        A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def currency(self) -> builtins.str:
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[Sequence['outputs.ShippingRateFixedAmountCurrencyOption']]:
        """
        Shipping rates defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. For example, to get your shipping rate in eur, fetch the value of the eur key in currency_options. This field is not included by default. To include it in the response, expand the currency_options field.
        """
        return pulumi.get(self, "currency_options")


@pulumi.output_type
class ShippingRateFixedAmountCurrencyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taxBehavior":
            suggest = "tax_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingRateFixedAmountCurrencyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingRateFixedAmountCurrencyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: builtins.int,
                 currency: builtins.str,
                 tax_behavior: Optional[builtins.str] = None):
        """
        :param builtins.int amount: A non-negative integer in cents representing how much to charge.
        :param builtins.str currency: Three-letter ISO currency code, in lowercase. Must be a supported currency.
        :param builtins.str tax_behavior: Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)

    @property
    @pulumi.getter
    def amount(self) -> builtins.int:
        """
        A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def currency(self) -> builtins.str:
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[builtins.str]:
        """
        Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified.
        """
        return pulumi.get(self, "tax_behavior")


