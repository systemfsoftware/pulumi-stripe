# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'FileLinkArgs',
    'FileLinkArgsDict',
    'FileLinkDataArgs',
    'FileLinkDataArgsDict',
    'PortalConfigurationBusinessProfileArgs',
    'PortalConfigurationBusinessProfileArgsDict',
    'PortalConfigurationFeaturesArgs',
    'PortalConfigurationFeaturesArgsDict',
    'PortalConfigurationFeaturesCustomerUpdateArgs',
    'PortalConfigurationFeaturesCustomerUpdateArgsDict',
    'PortalConfigurationFeaturesInvoiceHistoryArgs',
    'PortalConfigurationFeaturesInvoiceHistoryArgsDict',
    'PortalConfigurationFeaturesPaymentMethodUpdateArgs',
    'PortalConfigurationFeaturesPaymentMethodUpdateArgsDict',
    'PortalConfigurationFeaturesSubscriptionCancelArgs',
    'PortalConfigurationFeaturesSubscriptionCancelArgsDict',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict',
    'PortalConfigurationFeaturesSubscriptionPauseArgs',
    'PortalConfigurationFeaturesSubscriptionPauseArgsDict',
    'PortalConfigurationFeaturesSubscriptionUpdateArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateArgsDict',
    'PortalConfigurationFeaturesSubscriptionUpdateProductArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict',
    'PortalConfigurationLoginPageArgs',
    'PortalConfigurationLoginPageArgsDict',
    'PriceCurrencyOptionArgs',
    'PriceCurrencyOptionArgsDict',
    'PriceCurrencyOptionCustomUnitAmountArgs',
    'PriceCurrencyOptionCustomUnitAmountArgsDict',
    'PriceCurrencyOptionTierArgs',
    'PriceCurrencyOptionTierArgsDict',
    'PriceRecurringArgs',
    'PriceRecurringArgsDict',
    'PriceTierArgs',
    'PriceTierArgsDict',
    'PriceTransformQuantityArgs',
    'PriceTransformQuantityArgsDict',
    'PromotionCodeRestrictionsArgs',
    'PromotionCodeRestrictionsArgsDict',
    'ShippingRateDeliveryEstimateArgs',
    'ShippingRateDeliveryEstimateArgsDict',
    'ShippingRateDeliveryEstimateMaximumArgs',
    'ShippingRateDeliveryEstimateMaximumArgsDict',
    'ShippingRateDeliveryEstimateMinimumArgs',
    'ShippingRateDeliveryEstimateMinimumArgsDict',
    'ShippingRateFixedAmountArgs',
    'ShippingRateFixedAmountArgsDict',
    'ShippingRateFixedAmountCurrencyOptionArgs',
    'ShippingRateFixedAmountCurrencyOptionArgsDict',
]

MYPY = False

if not MYPY:
    class FileLinkArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[builtins.int]]
        """
        Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        expired: NotRequired[pulumi.Input[builtins.bool]]
        """
        Returns if the link is already expired.
        """
        expires_at: NotRequired[pulumi.Input[builtins.int]]
        """
        Time that the link expires
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Unique identifier for the object.
        """
        livemode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        object: NotRequired[pulumi.Input[builtins.str]]
        """
        String representing the object’s type. Objects of the same type share the same value.
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The publicly accessible URL to download the file.
        """
elif False:
    FileLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileLinkArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[builtins.int]] = None,
                 expired: Optional[pulumi.Input[builtins.bool]] = None,
                 expires_at: Optional[pulumi.Input[builtins.int]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 livemode: Optional[pulumi.Input[builtins.bool]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 object: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] created: Time at which the object was created. Measured in seconds since the Unix epoch.
        :param pulumi.Input[builtins.bool] expired: Returns if the link is already expired.
        :param pulumi.Input[builtins.int] expires_at: Time that the link expires
        :param pulumi.Input[builtins.str] id: Unique identifier for the object.
        :param pulumi.Input[builtins.bool] livemode: Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        :param pulumi.Input[builtins.str] object: String representing the object’s type. Objects of the same type share the same value.
        :param pulumi.Input[builtins.str] url: The publicly accessible URL to download the file.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if livemode is not None:
            pulumi.set(__self__, "livemode", livemode)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time at which the object was created. Measured in seconds since the Unix epoch.
        """
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "created", value)

    @property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Returns if the link is already expired.
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "expired", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time that the link expires
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unique identifier for the object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def livemode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        """
        return pulumi.get(self, "livemode")

    @livemode.setter
    def livemode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "livemode", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String representing the object’s type. Objects of the same type share the same value.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The publicly accessible URL to download the file.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FileLinkDataArgsDict(TypedDict):
        create: pulumi.Input[builtins.bool]
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        expires_at: NotRequired[pulumi.Input[builtins.int]]
        """
        The link isn’t available after this future timestamp.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
elif False:
    FileLinkDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileLinkDataArgs:
    def __init__(__self__, *,
                 create: pulumi.Input[builtins.bool],
                 expires_at: Optional[pulumi.Input[builtins.int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] create: Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        :param pulumi.Input[builtins.int] expires_at: The link isn’t available after this future timestamp.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        pulumi.set(__self__, "create", create)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def create(self) -> pulumi.Input[builtins.bool]:
        """
        Set this to true to create a file link for the newly created file. Creating a link is only possible when the file’s purpose is one of the following: business_icon, business_logo, customer_signature, dispute_evidence, pci_document, tax_document_user_upload, or terminal_reader_splashscreen.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The link isn’t available after this future timestamp.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class PortalConfigurationBusinessProfileArgsDict(TypedDict):
        headline: NotRequired[pulumi.Input[builtins.str]]
        """
        The messaging shown to customers in the portal.
        """
        privacy_policy_url: NotRequired[pulumi.Input[builtins.str]]
        """
        A link to the business's publicly available privacy policy.
        """
        terms_of_service_url: NotRequired[pulumi.Input[builtins.str]]
        """
        A link to the business's publicly available terms of service.
        """
elif False:
    PortalConfigurationBusinessProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationBusinessProfileArgs:
    def __init__(__self__, *,
                 headline: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_url: Optional[pulumi.Input[builtins.str]] = None,
                 terms_of_service_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] headline: The messaging shown to customers in the portal.
        :param pulumi.Input[builtins.str] privacy_policy_url: A link to the business's publicly available privacy policy.
        :param pulumi.Input[builtins.str] terms_of_service_url: A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @property
    @pulumi.getter
    def headline(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @headline.setter
    def headline(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "headline", value)

    @property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @privacy_policy_url.setter
    def privacy_policy_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_url", value)

    @property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")

    @terms_of_service_url.setter
    def terms_of_service_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "terms_of_service_url", value)


if not MYPY:
    class PortalConfigurationFeaturesArgsDict(TypedDict):
        customer_update: NotRequired[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgsDict']]
        """
        Information about updating the customer details in the portal.
        """
        invoice_history: NotRequired[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgsDict']]
        """
        Information about showing the billing history in the portal.
        """
        payment_method_update: NotRequired[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgsDict']]
        """
        Information about updating payment methods in the portal.
        """
        subscription_cancel: NotRequired[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgsDict']]
        """
        Information about canceling subscriptions in the portal.
        """
        subscription_pauses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgsDict']]]]
        """
        Information about pausing subscriptions in the portal.
        """
        subscription_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgsDict']]]]
        """
        Information about updating subscriptions in the portal.
        """
elif False:
    PortalConfigurationFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesArgs:
    def __init__(__self__, *,
                 customer_update: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']] = None,
                 invoice_history: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']] = None,
                 payment_method_update: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']] = None,
                 subscription_cancel: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']] = None,
                 subscription_pauses: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]] = None,
                 subscription_updates: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]] = None):
        """
        :param pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs'] customer_update: Information about updating the customer details in the portal.
        :param pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs'] invoice_history: Information about showing the billing history in the portal.
        :param pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs'] payment_method_update: Information about updating payment methods in the portal.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs'] subscription_cancel: Information about canceling subscriptions in the portal.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]] subscription_pauses: Information about pausing subscriptions in the portal.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]] subscription_updates: Information about updating subscriptions in the portal.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_pauses is not None:
            pulumi.set(__self__, "subscription_pauses", subscription_pauses)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]:
        """
        Information about updating the customer details in the portal.
        """
        return pulumi.get(self, "customer_update")

    @customer_update.setter
    def customer_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]):
        pulumi.set(self, "customer_update", value)

    @property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]:
        """
        Information about showing the billing history in the portal.
        """
        return pulumi.get(self, "invoice_history")

    @invoice_history.setter
    def invoice_history(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]):
        pulumi.set(self, "invoice_history", value)

    @property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]:
        """
        Information about updating payment methods in the portal.
        """
        return pulumi.get(self, "payment_method_update")

    @payment_method_update.setter
    def payment_method_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]):
        pulumi.set(self, "payment_method_update", value)

    @property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]:
        """
        Information about canceling subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_cancel")

    @subscription_cancel.setter
    def subscription_cancel(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]):
        pulumi.set(self, "subscription_cancel", value)

    @property
    @pulumi.getter(name="subscriptionPauses")
    def subscription_pauses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]]:
        """
        Information about pausing subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_pauses")

    @subscription_pauses.setter
    def subscription_pauses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]]):
        pulumi.set(self, "subscription_pauses", value)

    @property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]:
        """
        Information about updating subscriptions in the portal.
        """
        return pulumi.get(self, "subscription_updates")

    @subscription_updates.setter
    def subscription_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]):
        pulumi.set(self, "subscription_updates", value)


if not MYPY:
    class PortalConfigurationFeaturesCustomerUpdateArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
        allowed_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
elif False:
    PortalConfigurationFeaturesCustomerUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesCustomerUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 allowed_updates: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_updates: The types of customer updates that are supported. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The types of customer updates that are supported. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")

    @allowed_updates.setter
    def allowed_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_updates", value)


if not MYPY:
    class PortalConfigurationFeaturesInvoiceHistoryArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
elif False:
    PortalConfigurationFeaturesInvoiceHistoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesInvoiceHistoryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PortalConfigurationFeaturesPaymentMethodUpdateArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
elif False:
    PortalConfigurationFeaturesPaymentMethodUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesPaymentMethodUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionCancelArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
        cancellation_reason: NotRequired[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict']]
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        proration_behavior: NotRequired[pulumi.Input[builtins.str]]
        """
        Whether to create prorations when canceling subscriptions.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionCancelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 cancellation_reason: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 proration_behavior: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs'] cancellation_reason: Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        :param pulumi.Input[builtins.str] mode: Whether to cancel subscriptions immediately or at the end of the billing period.
        :param pulumi.Input[builtins.str] proration_behavior: Whether to create prorations when canceling subscriptions.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]:
        """
        Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer
        """
        return pulumi.get(self, "cancellation_reason")

    @cancellation_reason.setter
    def cancellation_reason(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]):
        pulumi.set(self, "cancellation_reason", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether to cancel subscriptions immediately or at the end of the billing period.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether to create prorations when canceling subscriptions.
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proration_behavior", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
        options: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Which cancellation reasons will be given as options to the customer.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 options: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] options: Which cancellation reasons will be given as options to the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Which cancellation reasons will be given as options to the customer.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionPauseArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the feature is enabled.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionPauseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionPauseArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionUpdateArgsDict(TypedDict):
        default_allowed_updates: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        enabled: pulumi.Input[builtins.bool]
        """
        Whether the feature is enabled.
        """
        products: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict']]]
        """
        The list of products that support subscription updates.
        """
        proration_behavior: NotRequired[pulumi.Input[builtins.str]]
        """
        Determines how to handle prorations resulting from subscription updates
        """
elif False:
    PortalConfigurationFeaturesSubscriptionUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateArgs:
    def __init__(__self__, *,
                 default_allowed_updates: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 enabled: pulumi.Input[builtins.bool],
                 products: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]],
                 proration_behavior: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] default_allowed_updates: The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        :param pulumi.Input[builtins.bool] enabled: Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]] products: The list of products that support subscription updates.
        :param pulumi.Input[builtins.str] proration_behavior: Determines how to handle prorations resulting from subscription updates
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The types of subscription updates that are supported. When empty, subscriptions are not updateable.
        """
        return pulumi.get(self, "default_allowed_updates")

    @default_allowed_updates.setter
    def default_allowed_updates(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "default_allowed_updates", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def products(self) -> pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]:
        """
        The list of products that support subscription updates.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Determines how to handle prorations resulting from subscription updates
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proration_behavior", value)


if not MYPY:
    class PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict(TypedDict):
        prices: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The list of price IDs for the product that a subscription can be updated to.
        """
        product: pulumi.Input[builtins.str]
        """
        The product id.
        """
elif False:
    PortalConfigurationFeaturesSubscriptionUpdateProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateProductArgs:
    def __init__(__self__, *,
                 prices: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 product: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prices: The list of price IDs for the product that a subscription can be updated to.
        :param pulumi.Input[builtins.str] product: The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @property
    @pulumi.getter
    def prices(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @prices.setter
    def prices(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "prices", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[builtins.str]:
        """
        The product id.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "product", value)


if not MYPY:
    class PortalConfigurationLoginPageArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
elif False:
    PortalConfigurationLoginPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortalConfigurationLoginPageArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param pulumi.Input[builtins.str] url: A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A shareable URL to the hosted portal login page. Your customers will be able to log in with their email and receive a link to their customer portal.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PriceCurrencyOptionArgsDict(TypedDict):
        currency: pulumi.Input[builtins.str]
        """
        Each currency must be a three-letter ISO currency code and a supported currency
        """
        custom_unit_amount: NotRequired[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgsDict']]
        """
        When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
        """
        tax_behavior: NotRequired[pulumi.Input[builtins.str]]
        """
        Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        tiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgsDict']]]]
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
        """
        unit_amount: NotRequired[pulumi.Input[builtins.int]]
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
elif False:
    PriceCurrencyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionArgs:
    def __init__(__self__, *,
                 currency: pulumi.Input[builtins.str],
                 custom_unit_amount: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']] = None,
                 tax_behavior: Optional[pulumi.Input[builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.str] currency: Each currency must be a three-letter ISO currency code and a supported currency
        :param pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs'] custom_unit_amount: When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
        :param pulumi.Input[builtins.str] tax_behavior: Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
        :param pulumi.Input[builtins.int] unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[builtins.str]:
        """
        Each currency must be a three-letter ISO currency code and a supported currency
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]:
        """
        When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
        """
        return pulumi.get(self, "custom_unit_amount")

    @custom_unit_amount.setter
    def custom_unit_amount(self, value: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]):
        pulumi.set(self, "custom_unit_amount", value)

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @tax_behavior.setter
    def tax_behavior(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tax_behavior", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]:
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)


if not MYPY:
    class PriceCurrencyOptionCustomUnitAmountArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
        """
        maximum: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum unit amount the customer can specify for this item.
        """
        minimum: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
        """
        preset: NotRequired[pulumi.Input[builtins.int]]
        """
        The starting unit amount which can be updated by the customer.
        """
elif False:
    PriceCurrencyOptionCustomUnitAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionCustomUnitAmountArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 maximum: Optional[pulumi.Input[builtins.int]] = None,
                 minimum: Optional[pulumi.Input[builtins.int]] = None,
                 preset: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
        :param pulumi.Input[builtins.int] maximum: The maximum unit amount the customer can specify for this item.
        :param pulumi.Input[builtins.int] minimum: The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
        :param pulumi.Input[builtins.int] preset: The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class PriceCurrencyOptionTierArgsDict(TypedDict):
        flat_amount: NotRequired[pulumi.Input[builtins.int]]
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        flat_amount_decimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        unit_amount: NotRequired[pulumi.Input[builtins.int]]
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        up_to: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
elif False:
    PriceCurrencyOptionTierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceCurrencyOptionTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[builtins.int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 up_to: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] flat_amount: The flat billing amount for an entire tier, regardless of the number of units in the tier.
        :param pulumi.Input[builtins.float] flat_amount_decimal: Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        :param pulumi.Input[builtins.int] unit_amount: The per unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        :param pulumi.Input[builtins.int] up_to: Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "flat_amount", value)

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "up_to", value)


if not MYPY:
    class PriceRecurringArgsDict(TypedDict):
        interval: pulumi.Input[builtins.str]
        """
        Specifies billing frequency. Either day, week, month or year.
        """
        aggregate_usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        """
        interval_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        """
        usage_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        """
elif False:
    PriceRecurringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceRecurringArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[builtins.str],
                 aggregate_usage: Optional[pulumi.Input[builtins.str]] = None,
                 interval_count: Optional[pulumi.Input[builtins.int]] = None,
                 usage_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] interval: Specifies billing frequency. Either day, week, month or year.
        :param pulumi.Input[builtins.str] aggregate_usage: Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        :param pulumi.Input[builtins.int] interval_count: The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        :param pulumi.Input[builtins.str] usage_type: Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[builtins.str]:
        """
        Specifies billing frequency. Either day, week, month or year.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @aggregate_usage.setter
    def aggregate_usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aggregate_usage", value)

    @property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @interval_count.setter
    def interval_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval_count", value)

    @property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
        """
        return pulumi.get(self, "usage_type")

    @usage_type.setter
    def usage_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage_type", value)


if not MYPY:
    class PriceTierArgsDict(TypedDict):
        flat_amount: NotRequired[pulumi.Input[builtins.int]]
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        flat_amount_decimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        unit_amount: NotRequired[pulumi.Input[builtins.int]]
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        unit_amount_decimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        up_to: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
elif False:
    PriceTierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[builtins.int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 up_to: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] flat_amount: The flat billing amount for an entire tier, regardless of the number of units in the tier.
        :param pulumi.Input[builtins.float] flat_amount_decimal: Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        :param pulumi.Input[builtins.int] unit_amount: The per unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        :param pulumi.Input[builtins.int] up_to: Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The flat billing amount for an entire tier, regardless of the number of units in the tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "flat_amount", value)

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The per unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "up_to", value)


if not MYPY:
    class PriceTransformQuantityArgsDict(TypedDict):
        divide_by: pulumi.Input[builtins.int]
        """
        Divide usage by this number.
        """
        round: pulumi.Input[builtins.str]
        """
        After division, either round the result up or down
        """
elif False:
    PriceTransformQuantityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PriceTransformQuantityArgs:
    def __init__(__self__, *,
                 divide_by: pulumi.Input[builtins.int],
                 round: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] divide_by: Divide usage by this number.
        :param pulumi.Input[builtins.str] round: After division, either round the result up or down
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> pulumi.Input[builtins.int]:
        """
        Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @divide_by.setter
    def divide_by(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "divide_by", value)

    @property
    @pulumi.getter
    def round(self) -> pulumi.Input[builtins.str]:
        """
        After division, either round the result up or down
        """
        return pulumi.get(self, "round")

    @round.setter
    def round(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "round", value)


if not MYPY:
    class PromotionCodeRestrictionsArgsDict(TypedDict):
        first_time_transaction: pulumi.Input[builtins.bool]
        """
        A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices
        """
        minimum_amount: pulumi.Input[builtins.int]
        """
        Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        minimum_amount_currency: pulumi.Input[builtins.str]
        """
        Three-letter ISO code for minimum_amount
        """
elif False:
    PromotionCodeRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromotionCodeRestrictionsArgs:
    def __init__(__self__, *,
                 first_time_transaction: pulumi.Input[builtins.bool],
                 minimum_amount: pulumi.Input[builtins.int],
                 minimum_amount_currency: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.bool] first_time_transaction: A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices
        :param pulumi.Input[builtins.int] minimum_amount: Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param pulumi.Input[builtins.str] minimum_amount_currency: Three-letter ISO code for minimum_amount
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        pulumi.set(__self__, "minimum_amount", minimum_amount)
        pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> pulumi.Input[builtins.bool]:
        """
        A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices
        """
        return pulumi.get(self, "first_time_transaction")

    @first_time_transaction.setter
    def first_time_transaction(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "first_time_transaction", value)

    @property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> pulumi.Input[builtins.int]:
        """
        Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @minimum_amount.setter
    def minimum_amount(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "minimum_amount", value)

    @property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> pulumi.Input[builtins.str]:
        """
        Three-letter ISO code for minimum_amount
        """
        return pulumi.get(self, "minimum_amount_currency")

    @minimum_amount_currency.setter
    def minimum_amount_currency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "minimum_amount_currency", value)


if not MYPY:
    class ShippingRateDeliveryEstimateArgsDict(TypedDict):
        maximum: NotRequired[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgsDict']]
        minimum: NotRequired[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgsDict']]
elif False:
    ShippingRateDeliveryEstimateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']] = None,
                 minimum: Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']] = None):
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input['ShippingRateDeliveryEstimateMaximumArgs']]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input['ShippingRateDeliveryEstimateMinimumArgs']]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ShippingRateDeliveryEstimateMaximumArgsDict(TypedDict):
        unit: pulumi.Input[builtins.str]
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        value: pulumi.Input[builtins.int]
        """
        Must be greater than 0.
        """
elif False:
    ShippingRateDeliveryEstimateMaximumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateMaximumArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] unit: The upper bound of the estimated range. If empty, represents no lower bound.
        :param pulumi.Input[builtins.int] value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[builtins.str]:
        """
        The upper bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ShippingRateDeliveryEstimateMinimumArgsDict(TypedDict):
        unit: pulumi.Input[builtins.str]
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        value: pulumi.Input[builtins.int]
        """
        Must be greater than 0.
        """
elif False:
    ShippingRateDeliveryEstimateMinimumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateDeliveryEstimateMinimumArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] unit: The lower bound of the estimated range. If empty, represents no lower bound.
        :param pulumi.Input[builtins.int] value: Must be greater than 0.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[builtins.str]:
        """
        The lower bound of the estimated range. If empty, represents no lower bound.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Must be greater than 0.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ShippingRateFixedAmountArgsDict(TypedDict):
        amount: pulumi.Input[builtins.int]
        """
        A non-negative integer in cents representing how much to charge.
        """
        currency: pulumi.Input[builtins.str]
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        currency_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgsDict']]]]
        """
        Shipping rates defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. For example, to get your shipping rate in eur, fetch the value of the eur key in currency_options. This field is not included by default. To include it in the response, expand the currency_options field.
        """
elif False:
    ShippingRateFixedAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateFixedAmountArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[builtins.int],
                 currency: pulumi.Input[builtins.str],
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]] = None):
        """
        :param pulumi.Input[builtins.int] amount: A non-negative integer in cents representing how much to charge.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase. Must be a supported currency.
        :param pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]] currency_options: Shipping rates defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. For example, to get your shipping rate in eur, fetch the value of the eur key in currency_options. This field is not included by default. To include it in the response, expand the currency_options field.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[builtins.int]:
        """
        A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[builtins.str]:
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]]:
        """
        Shipping rates defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency. For example, to get your shipping rate in eur, fetch the value of the eur key in currency_options. This field is not included by default. To include it in the response, expand the currency_options field.
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ShippingRateFixedAmountCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)


if not MYPY:
    class ShippingRateFixedAmountCurrencyOptionArgsDict(TypedDict):
        amount: pulumi.Input[builtins.int]
        """
        A non-negative integer in cents representing how much to charge.
        """
        currency: pulumi.Input[builtins.str]
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        tax_behavior: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified.
        """
elif False:
    ShippingRateFixedAmountCurrencyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShippingRateFixedAmountCurrencyOptionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[builtins.int],
                 currency: pulumi.Input[builtins.str],
                 tax_behavior: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] amount: A non-negative integer in cents representing how much to charge.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase. Must be a supported currency.
        :param pulumi.Input[builtins.str] tax_behavior: Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "currency", currency)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[builtins.int]:
        """
        A non-negative integer in cents representing how much to charge.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[builtins.str]:
        """
        Three-letter ISO currency code, in lowercase. Must be a supported currency.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified.
        """
        return pulumi.get(self, "tax_behavior")

    @tax_behavior.setter
    def tax_behavior(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tax_behavior", value)


