# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['PriceArgs', 'Price']

@pulumi.input_type
class PriceArgs:
    def __init__(__self__, *,
                 currency: pulumi.Input[builtins.str],
                 product: pulumi.Input[builtins.str],
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 billing_scheme: Optional[pulumi.Input[builtins.str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]] = None,
                 lookup_key: Optional[pulumi.Input[builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 nickname: Optional[pulumi.Input[builtins.str]] = None,
                 recurring: Optional[pulumi.Input['PriceRecurringArgs']] = None,
                 tax_behaviour: Optional[pulumi.Input[builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]] = None,
                 tiers_mode: Optional[pulumi.Input[builtins.str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[builtins.bool]] = None,
                 transform_quantity: Optional[pulumi.Input['PriceTransformQuantityArgs']] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None):
        """
        The set of arguments for constructing a Price resource.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase.
        :param pulumi.Input[builtins.str] product: The ID of the product that this price will belong to.
        :param pulumi.Input[builtins.bool] active: Whether the price can be used for new purchases. Defaults to true.
        :param pulumi.Input[builtins.str] billing_scheme: Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
               (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
               usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
               pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]] currency_options: Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
               currency
        :param pulumi.Input[builtins.str] lookup_key: A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
               object in a structured format.
        :param pulumi.Input[builtins.str] nickname: A brief description of the price, hidden from customers.
        :param pulumi.Input['PriceRecurringArgs'] recurring: The recurring components of a price such as interval and usage_type.
        :param pulumi.Input[builtins.str] tax_behaviour: Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
               unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
               documentation for billing_scheme.
        :param pulumi.Input[builtins.str] tiers_mode: Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
               period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[builtins.bool] transfer_lookup_key: If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        :param pulumi.Input['PriceTransformQuantityArgs'] transform_quantity: Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
               tiers
        :param pulumi.Input[builtins.int] unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
               unit_amount_decimal can be set
        """
        pulumi.set(__self__, "currency", currency)
        pulumi.set(__self__, "product", product)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if billing_scheme is not None:
            pulumi.set(__self__, "billing_scheme", billing_scheme)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)
        if lookup_key is not None:
            pulumi.set(__self__, "lookup_key", lookup_key)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)
        if recurring is not None:
            pulumi.set(__self__, "recurring", recurring)
        if tax_behaviour is not None:
            pulumi.set(__self__, "tax_behaviour", tax_behaviour)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if tiers_mode is not None:
            pulumi.set(__self__, "tiers_mode", tiers_mode)
        if transfer_lookup_key is not None:
            pulumi.set(__self__, "transfer_lookup_key", transfer_lookup_key)
        if transform_quantity is not None:
            pulumi.set(__self__, "transform_quantity", transform_quantity)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[builtins.str]:
        """
        Three-letter ISO currency code, in lowercase.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the price can be used for new purchases. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
        (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
        usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
        pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @billing_scheme.setter
    def billing_scheme(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "billing_scheme", value)

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]:
        """
        Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
        currency
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @lookup_key.setter
    def lookup_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lookup_key", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
        object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def recurring(self) -> Optional[pulumi.Input['PriceRecurringArgs']]:
        """
        The recurring components of a price such as interval and usage_type.
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: Optional[pulumi.Input['PriceRecurringArgs']]):
        pulumi.set(self, "recurring", value)

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
        unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behaviour")

    @tax_behaviour.setter
    def tax_behaviour(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tax_behaviour", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]:
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
        documentation for billing_scheme.
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
        period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @tiers_mode.setter
    def tiers_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tiers_mode", value)

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @transfer_lookup_key.setter
    def transfer_lookup_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "transfer_lookup_key", value)

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> Optional[pulumi.Input['PriceTransformQuantityArgs']]:
        """
        Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
        tiers
        """
        return pulumi.get(self, "transform_quantity")

    @transform_quantity.setter
    def transform_quantity(self, value: Optional[pulumi.Input['PriceTransformQuantityArgs']]):
        pulumi.set(self, "transform_quantity", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
        unit_amount_decimal can be set
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)


@pulumi.input_type
class _PriceState:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 billing_scheme: Optional[pulumi.Input[builtins.str]] = None,
                 currency: Optional[pulumi.Input[builtins.str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]] = None,
                 lookup_key: Optional[pulumi.Input[builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 nickname: Optional[pulumi.Input[builtins.str]] = None,
                 product: Optional[pulumi.Input[builtins.str]] = None,
                 recurring: Optional[pulumi.Input['PriceRecurringArgs']] = None,
                 tax_behaviour: Optional[pulumi.Input[builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]] = None,
                 tiers_mode: Optional[pulumi.Input[builtins.str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[builtins.bool]] = None,
                 transform_quantity: Optional[pulumi.Input['PriceTransformQuantityArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None):
        """
        Input properties used for looking up and filtering Price resources.
        :param pulumi.Input[builtins.bool] active: Whether the price can be used for new purchases. Defaults to true.
        :param pulumi.Input[builtins.str] billing_scheme: Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
               (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
               usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
               pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]] currency_options: Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
               currency
        :param pulumi.Input[builtins.str] lookup_key: A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
               object in a structured format.
        :param pulumi.Input[builtins.str] nickname: A brief description of the price, hidden from customers.
        :param pulumi.Input[builtins.str] product: The ID of the product that this price will belong to.
        :param pulumi.Input['PriceRecurringArgs'] recurring: The recurring components of a price such as interval and usage_type.
        :param pulumi.Input[builtins.str] tax_behaviour: Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
               unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
               documentation for billing_scheme.
        :param pulumi.Input[builtins.str] tiers_mode: Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
               period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[builtins.bool] transfer_lookup_key: If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        :param pulumi.Input['PriceTransformQuantityArgs'] transform_quantity: Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
               tiers
        :param pulumi.Input[builtins.str] type: One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription)
               purchase
        :param pulumi.Input[builtins.int] unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
               unit_amount_decimal can be set
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if billing_scheme is not None:
            pulumi.set(__self__, "billing_scheme", billing_scheme)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if currency_options is not None:
            pulumi.set(__self__, "currency_options", currency_options)
        if lookup_key is not None:
            pulumi.set(__self__, "lookup_key", lookup_key)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if recurring is not None:
            pulumi.set(__self__, "recurring", recurring)
        if tax_behaviour is not None:
            pulumi.set(__self__, "tax_behaviour", tax_behaviour)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if tiers_mode is not None:
            pulumi.set(__self__, "tiers_mode", tiers_mode)
        if transfer_lookup_key is not None:
            pulumi.set(__self__, "transfer_lookup_key", transfer_lookup_key)
        if transform_quantity is not None:
            pulumi.set(__self__, "transform_quantity", transform_quantity)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the price can be used for new purchases. Defaults to true.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
        (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
        usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
        pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @billing_scheme.setter
    def billing_scheme(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "billing_scheme", value)

    @property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Three-letter ISO currency code, in lowercase.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]:
        """
        Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
        currency
        """
        return pulumi.get(self, "currency_options")

    @currency_options.setter
    def currency_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionArgs']]]]):
        pulumi.set(self, "currency_options", value)

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @lookup_key.setter
    def lookup_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lookup_key", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
        object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def recurring(self) -> Optional[pulumi.Input['PriceRecurringArgs']]:
        """
        The recurring components of a price such as interval and usage_type.
        """
        return pulumi.get(self, "recurring")

    @recurring.setter
    def recurring(self, value: Optional[pulumi.Input['PriceRecurringArgs']]):
        pulumi.set(self, "recurring", value)

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
        unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behaviour")

    @tax_behaviour.setter
    def tax_behaviour(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tax_behaviour", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]:
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
        documentation for billing_scheme.
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
        period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @tiers_mode.setter
    def tiers_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tiers_mode", value)

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @transfer_lookup_key.setter
    def transfer_lookup_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "transfer_lookup_key", value)

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> Optional[pulumi.Input['PriceTransformQuantityArgs']]:
        """
        Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
        tiers
        """
        return pulumi.get(self, "transform_quantity")

    @transform_quantity.setter
    def transform_quantity(self, value: Optional[pulumi.Input['PriceTransformQuantityArgs']]):
        pulumi.set(self, "transform_quantity", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription)
        purchase
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
        unit_amount_decimal can be set
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "unit_amount_decimal", value)


@pulumi.type_token("stripe:index/price:Price")
class Price(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 billing_scheme: Optional[pulumi.Input[builtins.str]] = None,
                 currency: Optional[pulumi.Input[builtins.str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceCurrencyOptionArgs', 'PriceCurrencyOptionArgsDict']]]]] = None,
                 lookup_key: Optional[pulumi.Input[builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 nickname: Optional[pulumi.Input[builtins.str]] = None,
                 product: Optional[pulumi.Input[builtins.str]] = None,
                 recurring: Optional[pulumi.Input[Union['PriceRecurringArgs', 'PriceRecurringArgsDict']]] = None,
                 tax_behaviour: Optional[pulumi.Input[builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceTierArgs', 'PriceTierArgsDict']]]]] = None,
                 tiers_mode: Optional[pulumi.Input[builtins.str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[builtins.bool]] = None,
                 transform_quantity: Optional[pulumi.Input[Union['PriceTransformQuantityArgs', 'PriceTransformQuantityArgsDict']]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 __props__=None):
        """
        Create a Price resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] active: Whether the price can be used for new purchases. Defaults to true.
        :param pulumi.Input[builtins.str] billing_scheme: Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
               (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
               usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
               pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase.
        :param pulumi.Input[Sequence[pulumi.Input[Union['PriceCurrencyOptionArgs', 'PriceCurrencyOptionArgsDict']]]] currency_options: Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
               currency
        :param pulumi.Input[builtins.str] lookup_key: A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
               object in a structured format.
        :param pulumi.Input[builtins.str] nickname: A brief description of the price, hidden from customers.
        :param pulumi.Input[builtins.str] product: The ID of the product that this price will belong to.
        :param pulumi.Input[Union['PriceRecurringArgs', 'PriceRecurringArgsDict']] recurring: The recurring components of a price such as interval and usage_type.
        :param pulumi.Input[builtins.str] tax_behaviour: Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
               unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input[Union['PriceTierArgs', 'PriceTierArgsDict']]]] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
               documentation for billing_scheme.
        :param pulumi.Input[builtins.str] tiers_mode: Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
               period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[builtins.bool] transfer_lookup_key: If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        :param pulumi.Input[Union['PriceTransformQuantityArgs', 'PriceTransformQuantityArgsDict']] transform_quantity: Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
               tiers
        :param pulumi.Input[builtins.int] unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
               unit_amount_decimal can be set
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: PriceArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a Price resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param PriceArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(PriceArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active: Optional[pulumi.Input[builtins.bool]] = None,
                 billing_scheme: Optional[pulumi.Input[builtins.str]] = None,
                 currency: Optional[pulumi.Input[builtins.str]] = None,
                 currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceCurrencyOptionArgs', 'PriceCurrencyOptionArgsDict']]]]] = None,
                 lookup_key: Optional[pulumi.Input[builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 nickname: Optional[pulumi.Input[builtins.str]] = None,
                 product: Optional[pulumi.Input[builtins.str]] = None,
                 recurring: Optional[pulumi.Input[Union['PriceRecurringArgs', 'PriceRecurringArgsDict']]] = None,
                 tax_behaviour: Optional[pulumi.Input[builtins.str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceTierArgs', 'PriceTierArgsDict']]]]] = None,
                 tiers_mode: Optional[pulumi.Input[builtins.str]] = None,
                 transfer_lookup_key: Optional[pulumi.Input[builtins.bool]] = None,
                 transform_quantity: Optional[pulumi.Input[Union['PriceTransformQuantityArgs', 'PriceTransformQuantityArgsDict']]] = None,
                 unit_amount: Optional[pulumi.Input[builtins.int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = PriceArgs.__new__(PriceArgs)

            __props__.__dict__["active"] = active
            __props__.__dict__["billing_scheme"] = billing_scheme
            if currency is None and not opts.urn:
                raise TypeError("Missing required property 'currency'")
            __props__.__dict__["currency"] = currency
            __props__.__dict__["currency_options"] = currency_options
            __props__.__dict__["lookup_key"] = lookup_key
            __props__.__dict__["metadata"] = metadata
            __props__.__dict__["nickname"] = nickname
            if product is None and not opts.urn:
                raise TypeError("Missing required property 'product'")
            __props__.__dict__["product"] = product
            __props__.__dict__["recurring"] = recurring
            __props__.__dict__["tax_behaviour"] = tax_behaviour
            __props__.__dict__["tiers"] = tiers
            __props__.__dict__["tiers_mode"] = tiers_mode
            __props__.__dict__["transfer_lookup_key"] = transfer_lookup_key
            __props__.__dict__["transform_quantity"] = transform_quantity
            __props__.__dict__["unit_amount"] = unit_amount
            __props__.__dict__["unit_amount_decimal"] = unit_amount_decimal
            __props__.__dict__["type"] = None
        super(Price, __self__).__init__(
            'stripe:index/price:Price',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            active: Optional[pulumi.Input[builtins.bool]] = None,
            billing_scheme: Optional[pulumi.Input[builtins.str]] = None,
            currency: Optional[pulumi.Input[builtins.str]] = None,
            currency_options: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceCurrencyOptionArgs', 'PriceCurrencyOptionArgsDict']]]]] = None,
            lookup_key: Optional[pulumi.Input[builtins.str]] = None,
            metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
            nickname: Optional[pulumi.Input[builtins.str]] = None,
            product: Optional[pulumi.Input[builtins.str]] = None,
            recurring: Optional[pulumi.Input[Union['PriceRecurringArgs', 'PriceRecurringArgsDict']]] = None,
            tax_behaviour: Optional[pulumi.Input[builtins.str]] = None,
            tiers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PriceTierArgs', 'PriceTierArgsDict']]]]] = None,
            tiers_mode: Optional[pulumi.Input[builtins.str]] = None,
            transfer_lookup_key: Optional[pulumi.Input[builtins.bool]] = None,
            transform_quantity: Optional[pulumi.Input[Union['PriceTransformQuantityArgs', 'PriceTransformQuantityArgsDict']]] = None,
            type: Optional[pulumi.Input[builtins.str]] = None,
            unit_amount: Optional[pulumi.Input[builtins.int]] = None,
            unit_amount_decimal: Optional[pulumi.Input[builtins.float]] = None) -> 'Price':
        """
        Get an existing Price resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] active: Whether the price can be used for new purchases. Defaults to true.
        :param pulumi.Input[builtins.str] billing_scheme: Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
               (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
               usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
               pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        :param pulumi.Input[builtins.str] currency: Three-letter ISO currency code, in lowercase.
        :param pulumi.Input[Sequence[pulumi.Input[Union['PriceCurrencyOptionArgs', 'PriceCurrencyOptionArgsDict']]]] currency_options: Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
               currency
        :param pulumi.Input[builtins.str] lookup_key: A lookup key used to retrieve prices dynamically from a static string.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
               object in a structured format.
        :param pulumi.Input[builtins.str] nickname: A brief description of the price, hidden from customers.
        :param pulumi.Input[builtins.str] product: The ID of the product that this price will belong to.
        :param pulumi.Input[Union['PriceRecurringArgs', 'PriceRecurringArgsDict']] recurring: The recurring components of a price such as interval and usage_type.
        :param pulumi.Input[builtins.str] tax_behaviour: Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
               unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input[Union['PriceTierArgs', 'PriceTierArgsDict']]]] tiers: Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
               documentation for billing_scheme.
        :param pulumi.Input[builtins.str] tiers_mode: Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
               period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        :param pulumi.Input[builtins.bool] transfer_lookup_key: If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        :param pulumi.Input[Union['PriceTransformQuantityArgs', 'PriceTransformQuantityArgsDict']] transform_quantity: Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
               tiers
        :param pulumi.Input[builtins.str] type: One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription)
               purchase
        :param pulumi.Input[builtins.int] unit_amount: A positive integer in cents (or -1 for a free price) representing how much to charge.
        :param pulumi.Input[builtins.float] unit_amount_decimal: Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
               unit_amount_decimal can be set
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _PriceState.__new__(_PriceState)

        __props__.__dict__["active"] = active
        __props__.__dict__["billing_scheme"] = billing_scheme
        __props__.__dict__["currency"] = currency
        __props__.__dict__["currency_options"] = currency_options
        __props__.__dict__["lookup_key"] = lookup_key
        __props__.__dict__["metadata"] = metadata
        __props__.__dict__["nickname"] = nickname
        __props__.__dict__["product"] = product
        __props__.__dict__["recurring"] = recurring
        __props__.__dict__["tax_behaviour"] = tax_behaviour
        __props__.__dict__["tiers"] = tiers
        __props__.__dict__["tiers_mode"] = tiers_mode
        __props__.__dict__["transfer_lookup_key"] = transfer_lookup_key
        __props__.__dict__["transform_quantity"] = transform_quantity
        __props__.__dict__["type"] = type
        __props__.__dict__["unit_amount"] = unit_amount
        __props__.__dict__["unit_amount_decimal"] = unit_amount_decimal
        return Price(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def active(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Whether the price can be used for new purchases. Defaults to true.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="billingScheme")
    def billing_scheme(self) -> pulumi.Output[builtins.str]:
        """
        Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount
        (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with
        usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit
        pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
        """
        return pulumi.get(self, "billing_scheme")

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Output[builtins.str]:
        """
        Three-letter ISO currency code, in lowercase.
        """
        return pulumi.get(self, "currency")

    @property
    @pulumi.getter(name="currencyOptions")
    def currency_options(self) -> pulumi.Output[Optional[Sequence['outputs.PriceCurrencyOption']]]:
        """
        Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported
        currency
        """
        return pulumi.get(self, "currency_options")

    @property
    @pulumi.getter(name="lookupKey")
    def lookup_key(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        A lookup key used to retrieve prices dynamically from a static string.
        """
        return pulumi.get(self, "lookup_key")

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Output[Optional[Mapping[str, builtins.str]]]:
        """
        Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the
        object in a structured format.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def nickname(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        A brief description of the price, hidden from customers.
        """
        return pulumi.get(self, "nickname")

    @property
    @pulumi.getter
    def product(self) -> pulumi.Output[builtins.str]:
        """
        The ID of the product that this price will belong to.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def recurring(self) -> pulumi.Output[Optional['outputs.PriceRecurring']]:
        """
        The recurring components of a price such as interval and usage_type.
        """
        return pulumi.get(self, "recurring")

    @property
    @pulumi.getter(name="taxBehaviour")
    def tax_behaviour(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or
        unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behaviour")

    @property
    @pulumi.getter
    def tiers(self) -> pulumi.Output[Optional[Sequence['outputs.PriceTier']]]:
        """
        Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the
        documentation for billing_scheme.
        """
        return pulumi.get(self, "tiers")

    @property
    @pulumi.getter(name="tiersMode")
    def tiers_mode(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a
        period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
        """
        return pulumi.get(self, "tiers_mode")

    @property
    @pulumi.getter(name="transferLookupKey")
    def transfer_lookup_key(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
        """
        return pulumi.get(self, "transfer_lookup_key")

    @property
    @pulumi.getter(name="transformQuantity")
    def transform_quantity(self) -> pulumi.Output[Optional['outputs.PriceTransformQuantity']]:
        """
        Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with
        tiers
        """
        return pulumi.get(self, "transform_quantity")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[builtins.str]:
        """
        One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription)
        purchase
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> pulumi.Output[builtins.int]:
        """
        A positive integer in cents (or -1 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> pulumi.Output[builtins.float]:
        """
        Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and
        unit_amount_decimal can be set
        """
        return pulumi.get(self, "unit_amount_decimal")

